# 罐头和代码（Canisters and code）

要铭记的最重要的一个原则是`IC`是一个区块链，它以分布式、复制的方式运行软件。

编写运行在`IC`上的去中心化应用会被编译成`WASM`模块。当一个去中心化应用被部署到`IC`上时，它被称为罐头（`canister`）运行在一个概念上的计算单元里。

部署后，最终用户可以通过前端客户端（例如浏览器）访问你为该罐头定义的入口函数，并与罐头交互。


## 一个罐头共识包含逻辑代码和状态（Canisters include both program and state）

---- 

罐头智能合约类似于容器，两者都部署为一个软件单元，其中包含应用程序或服务的编译代码和依赖。

容器容许应用程序与环境解耦，从而实现轻松可靠的部署。然而，容器与罐头的不同之处在于罐头还能存储有关当前软件的运行状态。

虽然罐头可能包含有关应用程序运行环境状态的信息，但罐头能够持久地保存由于调用其函数而导致的状态变更记录。

## 查询和更新函数（Query and update methods）

这个由程序和状态组成的罐头的概念是一个重要的概念。特别是它与调用罐头端点时应该预期的行为有关。只有两种类型的调用：非提交的查询调用（`Query`，任何状态变更都被丢弃）和提交更新调用（`Update`，状态变更被持久化）。

|类型|关键点|
|----|-----|
|`Query`调用|允许用户查询罐头的当前状态或调用对容器状态进行操作而不改变它的函数</br> * 立即返回的同步调用。</br> * 哈哈的撒</br> * 可以对任何持有罐头的节点提交这个调用。调用的结果是没有通过共识的，也就是说，安全性和性能之间存在固有的权衡：来自单个节点的回复很快，但可能不可信或者不准确。 </br> * 不允许持久化对罐头的变更，因此，`Query`本质是只读操作。</br> * 不允许被调用的罐头调用其它罐头公开的函数。（请注意，此限制是暂时的，并且罐头在将来能够处理`Query`时调用其它罐头的函数。）|
|`Update`调用|允许用户更改容器的状态并使更改保持不变。</br> * 异步返回。</br> * `Update`调用都必须通过共识。因为需要达成共识，所以更改罐头的状态并返回结果可能需要一段时间。安全性和性能之间存在固有的权衡：罐头的`Update`调用的返回结果是值得信赖的，因为子网中三分之二的`replica`必须同意这个返回结果，但`Update`调用速度很小。</br> * 被调用的罐头可以调用其它罐头的公开函数。|

作为开发者，区分和认识`Update`调用和`Query`调用是很重要的。注意在安全性和性能之间权衡使用它们。

## 如何为`IC`开发去中心化应用（How to develop dapps for the Internet Computer）

对于程序员和软件开发人员，`IC`在一个框架内提供了独特的功能和机会，简化了你如何设计、构建和部署去中心化应用。该架构的一个关键部分是一种新的通用编程语言`Motoko`。`Motoko`是一种专门设计用于充分利用`IC`的独特功能的编程语言：

- 直接使用`Actor`对象和类定义程序的能力。
- 使用`async`、`await`语法进行异步编程，具有和同步编程一样的体验。
- 自动支持消息序列化和反序列化。
- 使用没有外部数据库或存储卷的数据结构来利用正交持久性的能力。

作为一种现代的高级语言，`Motoko`提供了自己的一些关键特性：

- 支持大整数运算和溢出保护。
- 一个健全的类型系统，静态检查每个程序，以确保它可以在所有可能的输入上没有类型错误的情况下执行。
- 支持函数抽象、用户定义的类型定义和用户定义的`Actor`。

有关`Motoko`的更多详细信息，比如语法约定、支持的功能，请参阅[`Motoko`语言指南](https://smartcontracts.org/docs/language-guide/motoko.html)。

下图提供了作为`IC`生态系统一部分的开发环境的自顶向下的视图：

![img](../../assets/images/d.svg "img")

## 罐头、`Actor`以及你编写的代码

使用`Motoko`编写程序时要牢记的最重要原则之一是`Motoko`使用基于`Actor`的编程模型。

`Actor`是一种特殊的对象，它在隔离状态下处理消息，使消息能够被远程和异步处理。

通常，每个罐头都包含一个`Actor`对象的编译代码。每个罐头还可以包含一些附加信息，例如接口描述或前端资源。你还可以创建包含多个罐头的项目，但每个罐头只能包含一个`Actor`。

## 为什么你的代码会被编译成`WASM`

当你编译`Motoko`代码时，编译结果是一个`WASM`模块。`WASM`是一种低级计算机指令格式，可移植并在大多数现代计算机硬件上干净地抽象程序执行。它广泛支持在互联网上运行地程序，并且非常适合部署旨在`IC`上运行的去中心化应用。

使用`Motoko`，开发人员可以将应用编译为可移植的`WASM`，同时开发者仍然使用简单的高级语言交付安全的去中心化应用。

`Motoko`语言提供了许多其它现代高级语言共有的特性————比如类型安全、模式匹配。此外，`Motoko`提供了内置支持，以使用参与者定义消息服务，这种方式特别适合`IC`，并且无论你是新手还是经验丰富的程序员都易于学习。

本指南在使用`SDK`编写程序的背景下介绍了`Motoko`编程语言的基本功能。有关`Motoko`编程语言本身的更多信息，请参阅[Motoko编程语言指南](https://smartcontracts.org/docs/language-guide/motoko.html)。

## 身份（`Identity`）和认证

用户发起的罐头操作和罐头到罐头之间的操作主要的区别之一是罐头在`IC`上具有明确注册的身份

`IC`上没有一个中心的地方让用户可以集中注册，但用户可以选择一个（或者多个）数字签名密钥来表示自己。用户的私钥用于签署消息，这些消息与他们的公钥一起发送到`IC`。`IC`对用户进行身份验证并将委托人传递给罐头————罐头可以根据委托人选择实施它想要的任何授权策略。

高层次来看，首次使用`IC`的用户在与`IC`的第一次交互期间生成一个未签名的密钥对并从公钥中获取他们的主要表示符（`principal identifier`）。返回用户使用已由用户代理安全存储的私钥（或多个密钥）进行身份验证。有权访问多个罐头的用户可以管理用于每个罐头关联的身份验证的密钥和设备。

单个用户可以拥有多个公钥密钥对，用于从不同设备（例如在不同计算机、手机或平板电脑上运行的浏览器）访问罐头，但这些派生密钥都映射到主标识符（`primary identifier`）。

## 资源消耗和`Cycles`

所有的罐头都消耗计算资源，包括用于执行的`CPU`周期、用于路由消息的带宽以及用于持久数据的存储。这些资源是使用称为`Cycle`的成本单位支付的。`Cycle`可以通过`ICP`转换而来，并由每个罐头存储在本地`Cycle`余额中。

- 罐头必须能够为完整执行（全部或全部执行）付费，但与一个周期单位相关的成本将使高效的的程序具有成本效益。
- 通过设置罐头最多能消耗多少个`Cycle`，`IC`可以防止恶意代码完全接管资源。
- `Cycle`旨在以稳定或通缩的方式反映运营的实际成本，以使程序执行的成本保持不变或随着运营效率的提高而降低。因此，从`ICP`到`Cycle`的转换率会根据当前的`ICP`市场价进行相应调整。运营成本的相对稳定性使得预测处理（例如，一百万条消息）所需的`Cycle`变得更加容易。

## 想了解更多吗？

如果你想了解更多与罐头相关的内容，请查看下面的链接：

- [罐头————新型的智能合约](https://www.youtube.com/watch?v=LKpGuBOXxtQ)
- [什么是`Dfinity Canister SDK`](https://www.youtube.com/watch?v=60uHQfoA8Dk)
- [部署你的第一个应用](https://www.youtube.com/watch?v=yqIoiyuGYNA)